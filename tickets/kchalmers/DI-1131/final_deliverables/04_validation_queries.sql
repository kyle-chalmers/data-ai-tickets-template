/***********************************************************************************************************************
DI-1131 Validation Queries for Contact Date Logic
Date: 2025-08-20
Author: Kyle Chalmers

Purpose: Validate that the optimized views correctly implement contact date logic:
- 1 PayoffUID: Both dates should be NULL
- 2 PayoffUIDs: One row with NULL first date, other with NULL last date
- 3+ PayoffUIDs: Two rows with NULLs, middle rows with both dates populated

Expected Results:
- All queries should return data showing the logic works correctly
- No logical inconsistencies (e.g., first_date > last_date)
***********************************************************************************************************************/

-- ===========================================
-- PHONE VIEW VALIDATION QUERIES
-- ===========================================

-- Test 1: Phone numbers with exactly 1 PayoffUID (should have both dates NULL)
SELECT 'PHONE_1_TO_1_VALIDATION' as TEST_TYPE,
       COUNT(*) as RECORD_COUNT,
       COUNT(CASE WHEN FIRST_POSSIBLE_CONTACT_DATE IS NULL AND LAST_POSSIBLE_CONTACT_DATE IS NULL THEN 1 END) as CORRECT_NULL_DATES,
       COUNT(CASE WHEN FIRST_POSSIBLE_CONTACT_DATE IS NOT NULL OR LAST_POSSIBLE_CONTACT_DATE IS NOT NULL THEN 1 END) as INCORRECT_NON_NULL_DATES
FROM (
    SELECT PHONE, COUNT(DISTINCT PAYOFFUID) as payoff_count
    FROM BUSINESS_INTELLIGENCE_DEV.ANALYTICS_PII.VW_PHONE_TO_PAYOFFUID_MATCH
    GROUP BY PHONE
    HAVING payoff_count = 1
) single_phone
JOIN BUSINESS_INTELLIGENCE_DEV.ANALYTICS_PII.VW_PHONE_TO_PAYOFFUID_MATCH v ON v.PHONE = single_phone.PHONE

UNION ALL

-- Test 2: Phone numbers with exactly 2 PayoffUIDs (should have specific pattern)
SELECT 'PHONE_1_TO_2_VALIDATION' as TEST_TYPE,
       COUNT(*) as RECORD_COUNT,
       COUNT(CASE WHEN (FIRST_POSSIBLE_CONTACT_DATE IS NULL AND LAST_POSSIBLE_CONTACT_DATE IS NOT NULL) 
                    OR (FIRST_POSSIBLE_CONTACT_DATE IS NOT NULL AND LAST_POSSIBLE_CONTACT_DATE IS NULL) THEN 1 END) as CORRECT_PATTERN,
       COUNT(CASE WHEN FIRST_POSSIBLE_CONTACT_DATE IS NULL AND LAST_POSSIBLE_CONTACT_DATE IS NULL THEN 1 END) as BOTH_NULL_COUNT
FROM (
    SELECT PHONE, COUNT(DISTINCT PAYOFFUID) as payoff_count
    FROM BUSINESS_INTELLIGENCE_DEV.ANALYTICS_PII.VW_PHONE_TO_PAYOFFUID_MATCH
    GROUP BY PHONE
    HAVING payoff_count = 2
) double_phone
JOIN BUSINESS_INTELLIGENCE_DEV.ANALYTICS_PII.VW_PHONE_TO_PAYOFFUID_MATCH v ON v.PHONE = double_phone.PHONE

UNION ALL

-- Test 3: Phone numbers with 3+ PayoffUIDs (should have boundary and middle rows)
SELECT 'PHONE_3_PLUS_VALIDATION' as TEST_TYPE,
       COUNT(*) as RECORD_COUNT,
       COUNT(CASE WHEN FIRST_POSSIBLE_CONTACT_DATE IS NULL OR LAST_POSSIBLE_CONTACT_DATE IS NULL THEN 1 END) as BOUNDARY_ROWS,
       COUNT(CASE WHEN FIRST_POSSIBLE_CONTACT_DATE IS NOT NULL AND LAST_POSSIBLE_CONTACT_DATE IS NOT NULL THEN 1 END) as MIDDLE_ROWS
FROM (
    SELECT PHONE, COUNT(DISTINCT PAYOFFUID) as payoff_count
    FROM BUSINESS_INTELLIGENCE_DEV.ANALYTICS_PII.VW_PHONE_TO_PAYOFFUID_MATCH
    GROUP BY PHONE
    HAVING payoff_count >= 3
) multi_phone
JOIN BUSINESS_INTELLIGENCE_DEV.ANALYTICS_PII.VW_PHONE_TO_PAYOFFUID_MATCH v ON v.PHONE = multi_phone.PHONE

UNION ALL

-- ===========================================
-- EMAIL VIEW VALIDATION QUERIES
-- ===========================================

-- Test 4: Email addresses with exactly 1 PayoffUID (should have both dates NULL)
SELECT 'EMAIL_1_TO_1_VALIDATION' as TEST_TYPE,
       COUNT(*) as RECORD_COUNT,
       COUNT(CASE WHEN FIRST_POSSIBLE_CONTACT_DATE IS NULL AND LAST_POSSIBLE_CONTACT_DATE IS NULL THEN 1 END) as CORRECT_NULL_DATES,
       COUNT(CASE WHEN FIRST_POSSIBLE_CONTACT_DATE IS NOT NULL OR LAST_POSSIBLE_CONTACT_DATE IS NOT NULL THEN 1 END) as INCORRECT_NON_NULL_DATES
FROM (
    SELECT EMAIL, COUNT(DISTINCT PAYOFFUID) as payoff_count
    FROM BUSINESS_INTELLIGENCE_DEV.ANALYTICS_PII.VW_EMAIL_TO_PAYOFFUID_MATCH
    GROUP BY EMAIL
    HAVING payoff_count = 1
) single_email
JOIN BUSINESS_INTELLIGENCE_DEV.ANALYTICS_PII.VW_EMAIL_TO_PAYOFFUID_MATCH v ON v.EMAIL = single_email.EMAIL

UNION ALL

-- Test 5: Email addresses with exactly 2 PayoffUIDs (should have specific pattern)
SELECT 'EMAIL_1_TO_2_VALIDATION' as TEST_TYPE,
       COUNT(*) as RECORD_COUNT,
       COUNT(CASE WHEN (FIRST_POSSIBLE_CONTACT_DATE IS NULL AND LAST_POSSIBLE_CONTACT_DATE IS NOT NULL) 
                    OR (FIRST_POSSIBLE_CONTACT_DATE IS NOT NULL AND LAST_POSSIBLE_CONTACT_DATE IS NULL) THEN 1 END) as CORRECT_PATTERN,
       COUNT(CASE WHEN FIRST_POSSIBLE_CONTACT_DATE IS NULL AND LAST_POSSIBLE_CONTACT_DATE IS NULL THEN 1 END) as BOTH_NULL_COUNT
FROM (
    SELECT EMAIL, COUNT(DISTINCT PAYOFFUID) as payoff_count
    FROM BUSINESS_INTELLIGENCE_DEV.ANALYTICS_PII.VW_EMAIL_TO_PAYOFFUID_MATCH
    GROUP BY EMAIL
    HAVING payoff_count = 2
) double_email
JOIN BUSINESS_INTELLIGENCE_DEV.ANALYTICS_PII.VW_EMAIL_TO_PAYOFFUID_MATCH v ON v.EMAIL = double_email.EMAIL

UNION ALL

-- Test 6: Email addresses with 3+ PayoffUIDs (should have boundary and middle rows)
SELECT 'EMAIL_3_PLUS_VALIDATION' as TEST_TYPE,
       COUNT(*) as RECORD_COUNT,
       COUNT(CASE WHEN FIRST_POSSIBLE_CONTACT_DATE IS NULL OR LAST_POSSIBLE_CONTACT_DATE IS NULL THEN 1 END) as BOUNDARY_ROWS,
       COUNT(CASE WHEN FIRST_POSSIBLE_CONTACT_DATE IS NOT NULL AND LAST_POSSIBLE_CONTACT_DATE IS NOT NULL THEN 1 END) as MIDDLE_ROWS
FROM (
    SELECT EMAIL, COUNT(DISTINCT PAYOFFUID) as payoff_count
    FROM BUSINESS_INTELLIGENCE_DEV.ANALYTICS_PII.VW_EMAIL_TO_PAYOFFUID_MATCH
    GROUP BY EMAIL
    HAVING payoff_count >= 3
) multi_email
JOIN BUSINESS_INTELLIGENCE_DEV.ANALYTICS_PII.VW_EMAIL_TO_PAYOFFUID_MATCH v ON v.EMAIL = multi_email.EMAIL;